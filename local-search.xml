<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计网知识（前端须知）</title>
    <link href="/2024/03/07/%E8%AE%A1%E7%BD%91%E7%9F%A5%E8%AF%86%EF%BC%88%E5%89%8D%E7%AB%AF%E9%A1%BB%E7%9F%A5%EF%BC%89/"/>
    <url>/2024/03/07/%E8%AE%A1%E7%BD%91%E7%9F%A5%E8%AF%86%EF%BC%88%E5%89%8D%E7%AB%AF%E9%A1%BB%E7%9F%A5%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="简单须知"><a href="#简单须知" class="headerlink" title="简单须知"></a>简单须知</h2><ol><li>计算机网络：是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。<img src="/2024/03/07/%E8%AE%A1%E7%BD%91%E7%9F%A5%E8%AF%86%EF%BC%88%E5%89%8D%E7%AB%AF%E9%A1%BB%E7%9F%A5%EF%BC%89/1.png" class=""></li><li>互联网、因特网、万维网<br>a. 三者关系   <img src="/2024/03/07/%E8%AE%A1%E7%BD%91%E7%9F%A5%E8%AF%86%EF%BC%88%E5%89%8D%E7%AB%AF%E9%A1%BB%E7%9F%A5%EF%BC%89/2.png" class="">b.三者介绍<ul><li><code>互联网internet</code>：凡是由能彼此通信的设备组成的网络就叫互联网，即使仅有两台机器（计算机、手机等），不论用何种技术使其彼此通信，都叫互联网，所以，互联网有广域网、城域网及局域网之分。</li><li><code>因特网Internet</code>：<ul><li>互联网中的一种，是由<strong>上千万台设备组成的网络</strong>（该网络具备很大的规模）。因特网使用TCP&#x2F;IP协议让不同的设备可以彼此通信。但使用<strong>TCP&#x2F;IP协议</strong>的网络并不一定是因特网，一个局域网也可以使用TCP&#x2F;IP协议。</li><li><code>TCP/IP协议</code>:由很多协议组成，不同类型的协议又被放在不同的层，因特网提供的服务一般包括有：www(万维网)服务，电子邮件服务，远程登录服务，文件传输服务（FTP），网络电话等等。</li></ul></li><li><code>万维网www</code>：大规模的、联机式的信息存储所，是无数个网络站点和网页的集合。只要<strong>应用层使用的是HTTP协议</strong>，就称为万维网（world wide web），之所以在浏览器里输入百度网址时，能看见百度网提供的网页，就是因为您的个人浏览器和百度网的服务器之间使用的是HTTP协议在交流。</li></ul></li></ol><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><h3 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h3><p>开放式系统互联通信参考模型,简称OSI，将计算机网络体系结构划分为以下7层</p><img src="/2024/03/07/%E8%AE%A1%E7%BD%91%E7%9F%A5%E8%AF%86%EF%BC%88%E5%89%8D%E7%AB%AF%E9%A1%BB%E7%9F%A5%EF%BC%89/3.png" class=""><h3 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP&#x2F;IP模型"></a>TCP&#x2F;IP模型</h3><img src="/2024/03/07/%E8%AE%A1%E7%BD%91%E7%9F%A5%E8%AF%86%EF%BC%88%E5%89%8D%E7%AB%AF%E9%A1%BB%E7%9F%A5%EF%BC%89/4.png" class=""><ul><li><strong>协议</strong>:不同的硬件,操作系统之间的通信,都需要规则,这种规则称为协议。</li><li><strong>TCP&#x2F;IP协议</strong>是互联网基础相关各类协议族的总称，进行通信时，会通过分层顺序和对方进行通信。客户端从应用层往下走，服务器端则从链路层往上走<br>        <img src="/2024/03/07/%E8%AE%A1%E7%BD%91%E7%9F%A5%E8%AF%86%EF%BC%88%E5%89%8D%E7%AB%AF%E9%A1%BB%E7%9F%A5%EF%BC%89/5.png" class=""></li><li><strong>TCP&#x2F;IP传输流</strong><br>           <img src="/2024/03/07/%E8%AE%A1%E7%BD%91%E7%9F%A5%E8%AF%86%EF%BC%88%E5%89%8D%E7%AB%AF%E9%A1%BB%E7%9F%A5%EF%BC%89/6.png" class=""></li><li><strong>IP协议（网络层）</strong>：通过IP地址，保证了联网设备的唯一性，实现了网络通信的面向无连接和不可靠的传输功能。IP协议只能指明数据包的源目通信方即”这是谁的送给谁的”，但不能保证数据包一定能到达对方，数据是否会被丢弃以及丢弃之后如何处理。</li><li><strong>ARP协议</strong>：寻找MAC地址（链路层）<ul><li>MAC地址是什么呢？简单说来就是两台相邻的路由器A和B，A怎么把数据传给B呢，它总要知道B的物理地址吧，物理地址就像门牌号一样</li></ul></li><li><strong>DNS服务（应用层）</strong>：解析域名为IP地址</li></ul><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h3><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>UDP协议全称是用户数据报协议,在网络中它用于处理数据报,是一种无连接，不可靠，基于报文的协议。<br>特点：</p><ol><li>面向无连接<ul><li>UDP不需要和TCP一样在发送数据前进行3次握手建立连接,想发数据就可以开始发送</li><li>只是数据报文的搬运工,不会对数据报文进行任何拆分和拼接操作</li></ul></li><li>有单播,多播,广播功能<ul><li>不仅支持一对一传输方式,同样支持一对多,多对多,多对一的方式</li></ul></li><li>是面向报文的<ul><li>发送方的UDP对应用程序交下来的报文,在添加首部后就向下交付IP层.不合并拆分,而是保留这些报文边界.因此,应用程序必须选择合适大小的报文</li></ul></li><li>不可靠性<ul><li>通信建立在无连接上,想发就发</li><li>收到什么数据就传递什么数据,不会备份数据,发送数据方也不会关心对方是否正确接收数据</li><li>网络环境时好时坏,但是由于UDP因为没有阻塞控制,一直会以恒定速度发送数据,即使网络条件不好,也不会对发送速率进行调整.</li></ul></li></ol><p>缺点：</p><ul><li>网络条件不好情况下会出现丢包</li></ul><p>优点：</p><ul><li>头部开销小,只有8字节，传输数据报文很高效，实时性要求高的地方有所作为（eg：电话视频会议等）。</li></ul><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>TCP协议全称为传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信。<br>特点：</p><ol><li>面向连接<ul><li>只数据发送之前必须在两端建立连接,建立方法为3次握手,为数据可靠的传输打下基础</li></ul></li><li>仅支持单播传输<ul><li>仅支持一对一数据传输,不支持多播和广播传输方式</li></ul></li><li>可靠传输<ul><li>对于可靠传输,判断丢包,误码靠的是TCP的段编号以及确认编号.</li><li>TCP为了保证报文传输可靠,就给每个包一个序号,同时序号也保证了传送到接收端实体的包的按序接收</li></ul></li><li>提供拥塞控制<ul><li>当网络出现拥塞时,TCP可以减小向网络注入数据的速率和数量,缓解拥塞</li></ul></li><li>TCP提供全双工通信.<ul><li>在两个实体之间可以同时交换数据(发送和接收数据同时发生互不影响）</li></ul></li></ol><p>优点：</p><ul><li>适用于要求可靠传输的应用,例如文件传输</li></ul><h5 id="连接和断开"><a href="#连接和断开" class="headerlink" title="连接和断开"></a>连接和断开</h5><p>连接<br>                    <img src="/2024/03/07/%E8%AE%A1%E7%BD%91%E7%9F%A5%E8%AF%86%EF%BC%88%E5%89%8D%E7%AB%AF%E9%A1%BB%E7%9F%A5%EF%BC%89/7.png" class=""><br>断开<br>                    <img src="/2024/03/07/%E8%AE%A1%E7%BD%91%E7%9F%A5%E8%AF%86%EF%BC%88%E5%89%8D%E7%AB%AF%E9%A1%BB%E7%9F%A5%EF%BC%89/8.png" class=""></p><ul><li>客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。</li><li>服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSE_WAIT 状态。</li><li>客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。</li><li>等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。</li><li>客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态</li><li>服务端收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 2MSL （最大报文段的生存时间）一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭。</li></ul><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><h4 id="URL和URI"><a href="#URL和URI" class="headerlink" title="URL和URI"></a>URL和URI</h4><p><strong>解释</strong></p><ul><li><strong>URL</strong> 指的是统一资源 <strong>定位符</strong>,是访问WEB网站需要输入的网站地址</li><li><strong>URI</strong>是指统一资源<strong>标识符</strong>,全称为Uniform Resource Identifier,它的作用是区分互联网中的不同资源,比如:HTML,图像,视频,程序等等</li><li><strong>URL是URI的一个子集</strong></li></ul><p><strong>URI格式</strong><br>                    <img src="/2024/03/07/%E8%AE%A1%E7%BD%91%E7%9F%A5%E8%AF%86%EF%BC%88%E5%89%8D%E7%AB%AF%E9%A1%BB%E7%9F%A5%EF%BC%89/9.png" class=""></p><ul><li><strong>协议名</strong>:<code>http:或https:</code>表示协议名称,不区分字母大小写,后加上&#x2F;&#x2F;.</li><li><strong>登录信息</strong>:<code>user:@pass</code>表示获取服务器资源的用户和密码.不推荐使用,不安全，不常用</li><li><strong>服务器地址</strong>:<ul><li>以域名形式<code>www.tutu.com</code></li><li>以IPv4形式<code>192.168.0.1</code>地址名;</li><li>以<code>[0:0:0:0:0:0:1]</code>这种方括号括起来的IPv6地址；</li></ul></li><li><strong>服务器端口号</strong>:<code>:8080</code>表示端口号，如果省略端口部分，将采用默认端口80</li><li><strong>文件路径</strong>:<code>/html/index.html</code>表示服务器文件的路径,资源访问位置，域名后的最后一个“&#x2F;”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“&#x2F;”开始到“#”为止，否则是直接到最后</li><li><strong>查询字符串（参数部分）</strong>:<code>?userId=1</code>表示文件路径中的参数 ,?后面以<code>key=value</code>形式,如果后面还需要加参数,用&amp;拼接</li><li>片段标识符:<code>#cn1</code>表示文件中某个位置.即平时网页锚点定位</li></ul><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><ul><li>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网服务器传输超文本到本地浏览器的传送协议。</li><li>工作于客户端-服务端架构,浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。<br></li></ul><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol><li>简单快速<br>a. 客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。<br>b. 由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快      </li><li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li></ol><h5 id="HTTP请求，响应，状态码"><a href="#HTTP请求，响应，状态码" class="headerlink" title="HTTP请求，响应，状态码"></a><a href="https://www.cnblogs.com/ranyonsue/p/5984001.html">HTTP请求，响应，状态码</a></h5><h5 id="与其他协议"><a href="#与其他协议" class="headerlink" title="与其他协议"></a>与其他协议</h5><img src="/2024/03/07/%E8%AE%A1%E7%BD%91%E7%9F%A5%E8%AF%86%EF%BC%88%E5%89%8D%E7%AB%AF%E9%A1%BB%E7%9F%A5%EF%BC%89/10.png" class="">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>js基础</title>
    <link href="/2024/03/06/js%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/03/06/js%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="1-JavaScript简介"><a href="#1-JavaScript简介" class="headerlink" title="1.JavaScript简介"></a>1.JavaScript简介</h2><ul><li><p>JavaScript 是一门跨平台、面向对象的脚本语言，它能使网页可交互（例如拥有复杂的动画，可点击的按钮，通俗的菜单等）。另外还有高级的服务端 Javascript 版本，例如 Node.js，它可以让你在网页上添加更多功能，不仅仅是下载文件（例如在多台电脑之间的协同合作）。在宿主环境（例如 web 浏览器）中，JavaScript 能够通过其所连接的环境提供的编程接口进行控制。</p></li><li><p>JavaScript是一种动态弱类型语言</p><table><thead><tr><th align="center">JavaScript</th><th align="center">Java</th></tr></thead><tbody><tr><td align="center">面向对象。不区分对象类型。通过原型机制继承，任何对象的属性和方法均可以被动态添加。存放任意类型。</td><td align="center">基于类系统。分为类和实例，通过类层级的定义实现继承。不能动态增加对象或类的属性或方法。存放指定类型。</td></tr><tr><td align="center">变量类型不需要提前声明 (动态类型)。任意时刻存放</td><td align="center">变量类型必须提前声明 (静态类型)。</td></tr><tr><td align="center">不能直接自动写入硬盘</td><td align="center">可以直接自动写入硬盘。</td></tr></tbody></table></li><li><p>如今，JavaScript 已经成为了与 HTML&#x2F;CSS 完全集成的，使用最广泛的浏览器语言。</p></li></ul><h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h2><p>我们可以使用 var、let 或 const 声明变量来存储数据。</p><ul><li>let—现代的变量声明方式。</li><li>var—老旧的变量声明方式。一般情况下，我们不会再使用它。<br><em>（var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined）</em><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var a <span class="hljs-operator">=</span> []<span class="hljs-comment">;</span><br>for (var i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; 10; i++) &#123;</span><br>  a[i] <span class="hljs-operator">=</span> function () &#123;<br>    console.log(i)<span class="hljs-comment">;</span><br>  &#125;<span class="hljs-comment">;</span><br>&#125;<br>a[<span class="hljs-number">6</span>]()<span class="hljs-comment">;//10</span><br>//var声明的变量不具备块级作用域特性，是全局变量<br></code></pre></td></tr></table></figure></li><li>const—类似于let，但是变量的值<strong>无法被修改</strong> 。<div style="border: #e5b832 solid 2px; border-radius: 10px; background-color: antiquewhite; padding: 5px;">变量应当以一种容易理解变量内部是什么的方式进行命名。</div></li></ul><h2 id="3-JavaScript标识符"><a href="#3-JavaScript标识符" class="headerlink" title="3.JavaScript标识符"></a>3.JavaScript标识符</h2><p>所有JavaScript变量必须<strong>以唯一的名称</strong>的标识。<br>这些唯一的名称称为标识符。<br>构造变量名称（唯一标识符）的通用规则是：</p><ul><li>名称可包含字母、数字、下划线和美元符号</li><li>名称也可以以字母，$和_开头</li><li>名称对大小写敏感（y和Y是不同的变量）</li><li>保留字无法用作变量名称</li></ul><p>##数据类型<br>JavaScript 中有八种基本的数据类型（译注：前七种为基本数据类型，也称为原始类型，而 object 为复杂数据类型）。</p><ul><li>Number<ul><li>用于任何类型的数字：整数或浮点数，在 ±(253-1) 范围内的整数。</li></ul></li><li>Bigint<ul><li>用于任意长度的整数。</li></ul></li><li>String<ul><li>用于字符串：一个字符串可以包含 0 个或多个字符，所以没有单独的单字符类型。</li></ul></li><li>Boolean<ul><li>用于 true 和 false。</li><li>true不一定等于1,false不一定等于0。</li></ul></li><li>Null<ul><li>用于未知的值 —— 只有一个 null 值的独立类型。</li><li>null是表示一个空对象指针。</li></ul></li><li>Undefined<ul><li>用于未定义的值 —— 只有一个 undefined 值的独立类型。</li><li>在使用var 声明变量但未对其加初始化时，这个变量就是undefined。</li></ul></li><li>Symbol<ul><li>用于唯一的标识符。</li></ul></li><li>Object<ul><li>用于更复杂的数据结构，比如 function、Array、Date。</li></ul></li></ul><div style="border: #e5b832 solid 2px; border-radius: 7px; background-color: antiquewhite; padding: 5px;">我们可以通过 typeof 运算符查看存储在变量中的数据类型。</div><br><ul><li>我们可以通过 typeof 运算符查看存储在变量中的数据类型。</li><li>以字符串的形式返回类型名称，例如 “string”。</li><li>typeof null 会返回 “object” —— 这是 JavaScript 编程语言的一个错误，实际上它并不是一个 object。</li></ul><h2 id="5-值的比较"><a href="#5-值的比较" class="headerlink" title="5.值的比较"></a>5.值的比较</h2><ul><li><p>运算符</p><table><thead><tr><th align="center">等值检测运算符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x3D;&#x3D;（不相等）</td><td align="center">比较两个操作数的值是否相等</td></tr><tr><td align="center">!&#x3D;（不相等）</td><td align="center">比较两个操作数的值是否不相等</td></tr><tr><td align="center">&#x3D;&#x3D;&#x3D;（全等）</td><td align="center">比较两个操作数的值是否相等，同时检测它们的类型是否相同</td></tr><tr><td align="center">!&#x3D;&#x3D;（不全等）</td><td align="center">比较两个操作数的值是否不相等，同时检测它们的类型是否不相同</td></tr></tbody></table></li><li><p>比较规则</p><p> 1.比较运算符始终返回布尔值。<br> 2.字符串的比较，会按照“词典”顺序逐字符地比较大小。<br> 3.在相等运算中，应注意以下几个问题：</p><ul><li>如果操作数是布尔值，则先转换为数值，其中false转为0，true转换为1。</li><li>果一个操作数是字符串，另一个操作数是数字，则先尝试把字符串转换为数字。</li><li>如果一个操作数是字符串，另一个操作数是对象，则先尝试把对象转换为字符串。</li><li>如果一个操作数是数字，另一个操作数是对象，则先尝试把对象转换为数字。</li><li>如果两个操作数都是对象，则比较引用地址。如果引用地址相同，则相等；否则不等。  <div style="border: #e5b832 solid 2px; border-radius: 7px; background-color: antiquewhite; padding: 5px;">  <ol>  <li>在非严格相等 == 下，null 和 undefined 相等且各自不等于任何其他的值。</li>  <li>NaN与任何值都不相等，包括它自己。任何操作数与NaN比较，都是false</li>  <li>在使用>或&lt进行比较时，需要注意变量可能为 null/undefined 的情况。比较好的方法是单独检查变量是否等于 null/undefined。</li>  </ol>  </div></li></ul></li></ul><h2 id="6-类型转换"><a href="#6-类型转换" class="headerlink" title="6.类型转换"></a>6.类型转换</h2><ol><li><p>显式类型转换<br><br>a. 显式类型转换</p><ul><li><strong>toString()</strong><br>该方法不会影响到原变量，它会将转换的结构返回。但是注意，Null和Undefined没有toString()方法，如果调用它们的方法，则会报错。<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var a <span class="hljs-operator">=</span> <span class="hljs-number">123</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> a.toString()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><strong>String()</strong><br> 将被转换的数据作为参数传递给函数。使用String函数做类型强制转换时，对于Number和Boolean就是调用toString()方法，对于null和undefined，就不会调用toString()方法，它会将null直接转换成”null”，将undefined转换成”undefined”。 <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var a <span class="hljs-operator">=</span> <span class="hljs-number">123</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> String(a)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul><p>b.将其他的数据类型转换为Number类型</p><ul><li>Number()<br>   1.如果是纯数字的字符串，则直接将其转换为数字。<br>   2.如果字符串中有非数字的内容，则转换为NaN。<br>   3.布尔类型转换成数字：Ture转成1；False转成0。<br>   4.Null转成数字0。<br>   5.Undefined转成数字NaN。<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;123&#x27;</span>;<br>a = <span class="hljs-built_in">Number</span>(a);<span class="hljs-comment">//a:123</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;123abc&#x27;</span>;<br>a = <span class="hljs-built_in">Number</span>(a);<span class="hljs-comment">//a:NaN</span><br></code></pre></td></tr></table></figure></li></ul><ul><li>parseInt()，parseFloat()  <div style="border: #e5b832 solid 2px; border-radius: 7px; background-color: antiquewhite; padding: 5px;">针对字符串转换成数字</div></li></ul><ol><li>parseInt()把一个字符串转换为一个整数，只取整数部分；</li><li>parseFloat()把一个字符串转换为一个浮点数，可获得有效小数;</li><li>对非String使用parseInt()或parseFloat()，它会将其转换为String.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;123abc&#x27;</span>,<br><span class="hljs-keyword">var</span> b = <span class="hljs-string">&#x27;12.34.56ab&#x27;</span>;<br>a = <span class="hljs-built_in">parseInt</span>(a);<span class="hljs-comment">//a:123</span><br>b = <span class="hljs-built_in">parseFloat</span>(b);<span class="hljs-comment">//b:12.34</span><br></code></pre></td></tr></table></figure></li></ol><p>c.将其他的数据类型转换为Boolean类型</p><ul><li>Boolean（）<br> 1.对于数字，0和NaN是false，其余的都是true。<br> 2.对于字符串，空串是false，其余的都是true。<br> 3.对于null和undefined，都是false。<br> 4.对于对象，都是true。</li></ul></li><li><p>隐式类型转换<br>a. 转换为String类型</p><ul><li>为任意的数据加一个空串   <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;<br>a = a + ‘’;<span class="hljs-comment">//a:&quot;123&quot;</span><br></code></pre></td></tr></table></figure></li></ul><p>b. 转换为Number类型</p><ul><li>在数据前面放个+   <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">var <span class="hljs-keyword">a</span> = <span class="hljs-string">&#x27;123&#x27;</span><br><span class="hljs-keyword">a</span> = +<span class="hljs-keyword">a</span><span class="hljs-comment">;//a:123</span><br></code></pre></td></tr></table></figure></li></ul><p>c. 转换为Boolean类型</p><ul><li>为任意的数据取两次反   <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br>a = !!a;<span class="hljs-comment">//a:true</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="7-函数"><a href="#7-函数" class="headerlink" title="7.函数"></a>7.函数</h2><ol><li><p>函数是什么<br>a. 函数是在其中有一组代码的逻辑构件，用来执行特定任务。实际上为了易于调试和维护，函数允许以更有组织的方式去编写代码。函数还允许代码重用。</p><p>b. 在JavaScript里，函数实际上是对象， 每个函数都是Function类型的实例， 而Function也有属性和方法。因为函数是对象， 所以函数名就是指向函数对象的指针</p></li><li><p>如何创建一个函数？<br>a. 使用Function构造函数创建函数</p><ul><li>在这种方法中，函数是在“函数”的构造函数的帮助下创建的。从技术上讲，这种方法比使用函数表达式语法和函数声明语句语法去声明函数的方法效率要低。   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sum2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">&quot;a1&quot;</span>, <span class="hljs-string">&quot;a2&quot;</span>, <span class="hljs-string">&quot;return a1 + a2&quot;</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>));<span class="hljs-comment">//4</span><br></code></pre></td></tr></table></figure></li></ul><p>b. 使用函数表达式</p><ul><li>通常这种方法与变量分配相同。简而言之，函数主体被视为一个表达式，并且该表达式被分配给一个变量。使用这种语法定义的函数可以是命名函数或匿名函数。   <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const <span class="hljs-built_in">sum</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">a1, a2</span>) &#123;<br>    <span class="hljs-keyword">return</span> a1 + a2<br>&#125;<br>let a = <span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a) <br></code></pre></td></tr></table></figure>c. 使用函数声明</li></ul><ul><li>这种方法是JavaScript中常用的老派方法。在关键字“function”之后，你必须指定函数的名称。之后，如果函数接受多个参数或参数，也需要提及它们。虽然这部分是完全可选的。   <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> 函数名(<span class="hljs-params">参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span></span>) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;我是一个函数&quot;</span>)<br>&#125;<br>例 ： <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a1 , a2</span>) &#123;<br><span class="hljs-keyword">return</span> a1 + a2<br>&#125;<br>let a=<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>d. 箭头函数</li><li>箭头函数相当于是函数表达式创建函数的更短的版本，但是相对于函数声明，不能使用 arguments，super，也不能用作构造函数，也没有prototype属性   <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let 函数名 = <span class="hljs-function">(<span class="hljs-params">参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span></span>) =&gt;</span> &#123;<br>&#125;<br>const frontEnd = <span class="hljs-function">(<span class="hljs-params">frontEnd</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(frontEnd + <span class="hljs-string">&#x27; yyds&#x27;</span>)<br>&#125;<br>frontEnd(<span class="hljs-string">&#x27;frontEnd&#x27;</span>)<br><span class="hljs-comment">//如果只有一个参数，甚至可以省略圆括号，使代码更短</span><br>const fe = <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a + <span class="hljs-number">1</span><br><span class="hljs-comment">//如果没有参数，圆括号将是空的（但圆括号应该保留）</span><br>let sayHi = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> alert(<span class="hljs-string">&quot;Hello!&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>函数参数<br>a. 函数重载</p><ul><li>函数通过参数的个数和类型不同来创建不同的函数签名，通过调用函数时传入的参数个数和参数类型来进行命名参数的验证。</li><li>但是,在js中后声明的同名函数会对前面声明的函数进行一个覆盖</li></ul><p>b. 默认函数值</p><ul><li>在有默认参数的函数中，调用arguments</li><li>函数的默认参数只有在函数被调用的时候才会求值，不会在函数定义时求值</li><li>计算默认值的函数只有在调用函数但未传相应参数时才会被调用   <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">names</span>(<span class="hljs-params">name = <span class="hljs-string">&#x27;frontEnd&#x27;</span></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(name);<br>&#125;<br>names()<span class="hljs-comment">//frontend</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;我被调用了&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">al</span>(<span class="hljs-params">l = log(</span>)) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(l);<br>&#125;<br>al(<span class="hljs-number">1</span>);<span class="hljs-comment">//1</span><br>al();<span class="hljs-comment">//我被调用了 2</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><p>c. 类数组arguments对象</p><ul><li>如果一个函数传递了三个参数，你可以以如下方式引用他们：   <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">arguments</span>[<span class="hljs-number">0</span>]<br><span class="hljs-attribute">arguments</span>[<span class="hljs-number">1</span>]<br><span class="hljs-attribute">arguments</span>[<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> = <span class="hljs-title">function</span> <span class="hljs-params">()</span></span> &#123;<br> console.log(arguments);<br> console.log(arguments[<span class="hljs-number">0</span>]);<br>&#125;<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)</span></span><br><span class="hljs-comment">//Argument(5)[1,2,3,4,5]</span><br><span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure></li></ul><p>d. 将函数当作参数</p><ul><li>顾名思义，就是某个函数的参数是另一个函数<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">callSomeFunction</span>(someFunction, someArgnment) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">someFunction(someArgnment)</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(number) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">number</span> + <span class="hljs-number">10</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span>(name) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">&#x27;Hello</span> &#x27; + name<br>&#125;<br><br>let result = callSomeFunction(add, <span class="hljs-number">10</span>)<br><br>console.log(result);<br><br>let result2 = callSomeFunction(sayHello, <span class="hljs-symbol">&#x27;xiaobb</span>&#x27;)<br><br>console.log(result2);<br></code></pre></td></tr></table></figure></li></ul><ol start="4"><li>回调函数<ul><li>回调函数是一个函数，将会在另一个函数完成执行后立即执行。回调函数是一个作为参数传给另一个 JavaScript 函数的函数。这个回调函数会在传给的函数内部执行。</li></ul></li></ol><h3 id="面向对象（Object-oriented-programming）的思想"><a href="#面向对象（Object-oriented-programming）的思想" class="headerlink" title="面向对象（Object-oriented programming）的思想"></a>面向对象（Object-oriented programming）的思想</h3><ol><li>面向过程，就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步步实现，使用时在一个个调用函数就行了</li><li>面向对象，就是把事务分解成一个个对象，然后由对象之间分工合作完成。面向对象是以对象功能来划分问题</li></ol><p>面向对象的思路，是赋予冰箱开门关门的操作，给大象进门的操作，然后冰箱和大象两个对象合作完成任务；</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">打开冰箱门<br>把大象塞进冰箱<br>关冰箱门<br></code></pre></td></tr></table></figure><div style="border: #e5b832 solid 2px; border-radius: 7px; background-color: antiquewhite; padding: 5px;">     <li>面向过程的优点：性能比面向对象高，比较适合和硬件联系紧密的东西</li>     <li>面向对象的优点：易维护、易复用、易扩展、更适合多人合作的大项目</li>     </div>     <h3 id="对象"><a href="#对象" class="headerlink" title="对象:"></a>对象:</h3><div style="border: #e5b832 solid 2px; border-radius: 7px; background-color: antiquewhite; padding: 5px;">    对象（object）是大括号定义的无序的数据集合，由键值对构成     </div><p>对象也是变量。但是对象包含很多值。</p><p>这段代码把多个值（20230001, 21, 张三）赋给名为 student的变量：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">var student</span>= &#123;id:<span class="hljs-string">&quot;20230001&quot;</span>, age:21, name:<span class="hljs-string">&quot;张三&quot;</span>&#125;;<br></code></pre></td></tr></table></figure>值以名称:值对（即键值对）的方式来书写（名称和值由冒号分隔）。<br>JavaScript 对象是被命名值的容器。<h4 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h4><p>（JavaScript 对象中的）名称:值对被称为属性。<br><br>我们也可以理解为对象的状态或对象的数据</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> student =&#123;<br>    <span class="hljs-built_in">status</span>:<span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h4><p>对象也可以有方法。<br>方法是在对象上执行的动作。<br>方法以函数定义被存储在属性中。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> student =&#123;<br>    <span class="hljs-attr">sayhello</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br>    &#125;，<br>    <span class="hljs-comment">// 简写</span><br>    sayhi()&#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;hi&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">var</span> person = &#123;<br>  <span class="hljs-attribute">firstName</span>: <span class="hljs-string">&quot;Bill&quot;</span>,<br>  <span class="hljs-attribute">lastName</span> : <span class="hljs-string">&quot;Gates&quot;</span>,<br>  <span class="hljs-attribute">id       :</span><span class="hljs-string"> 678,</span><br><span class="hljs-string">  fullName</span> : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstName + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-keyword">this</span>.lastName;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="访问对象属性"><a href="#访问对象属性" class="headerlink" title="访问对象属性"></a>访问对象属性</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">objectName.propertyName<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">objectName<span class="hljs-selector-attr">[<span class="hljs-string">&quot;propertyName&quot;</span>]</span><br></code></pre></td></tr></table></figure><div style="border: #e5b832 solid 2px; border-radius: 7px; background-color: antiquewhite; padding: 5px;">  obj1["key"] 是使用方括号语法访问对象属性，其中 "key" 是属性名的字符串表示。这种方式允许在方括号中使用变量或表达式来指定属性名，因此可以动态地访问对象的属性。例如：     </div><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> obj = &#123; <span class="hljs-built_in">key</span>: <span class="hljs-string">&quot;value&quot;</span> &#125;;<br><span class="hljs-built_in">let</span> propertyName = <span class="hljs-string">&quot;key&quot;</span>;<br>console.<span class="hljs-built_in">log</span>(obj[propertyName]); // 输出 <span class="hljs-string">&quot;value&quot;</span><br></code></pre></td></tr></table></figure><div style="border: #e5b832 solid 2px; border-radius: 7px; background-color: antiquewhite; padding: 5px;"> obj.key 是使用点语法访问对象属性，其中 key 是属性名。这种方式只能使用硬编码的属性名，不能使用变量或表达式。例如：     </div><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> obj = &#123; <span class="hljs-built_in">key</span>: <span class="hljs-string">&quot;value&quot;</span> &#125;;<br>console.<span class="hljs-built_in">log</span>(obj.<span class="hljs-built_in">key</span>); // 输出 <span class="hljs-string">&quot;value&quot;</span><br></code></pre></td></tr></table></figure><h3 id="访问对象方法"><a href="#访问对象方法" class="headerlink" title="访问对象方法"></a>访问对象方法</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">objectName<span class="hljs-selector-class">.methodName</span>()<br></code></pre></td></tr></table></figure><h3 id="对象的声明方式"><a href="#对象的声明方式" class="headerlink" title="对象的声明方式"></a>对象的声明方式</h3><ol><li>声明字面量对象</li><li>通过Object类创建对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建空对象</span><br><span class="hljs-keyword">let</span> obj1 = &#123;&#125;<br><span class="hljs-keyword">let</span> obj2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-comment">// 添加属性</span><br>obj1.<span class="hljs-property">key1</span> = <span class="hljs-string">&quot;value1&quot;</span><br>obj2.<span class="hljs-property">key2</span> = <span class="hljs-number">12</span><br>obj1[<span class="hljs-string">&quot;key&quot;</span>] = <span class="hljs-literal">false</span><br><span class="hljs-comment">// 添加方法</span><br>obj2.<span class="hljs-property">hi</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hi&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="8-JS数组与字符串"><a href="#8-JS数组与字符串" class="headerlink" title="8.JS数组与字符串"></a>8.JS数组与字符串</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="字符串是什么？"><a href="#字符串是什么？" class="headerlink" title="字符串是什么？"></a>字符串是什么？</h4><p><em>上过小学二年级的我们都知道，JS有7种基本数据类型和复杂数据类型，基本数据类型存储在栈中，和其他语言不同，JS中的字符串是基本数据类型中的一种</em></p><h4 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h4><p>字符串可以用双引号包裹，也可以用单引号包裹，JS中的字符串是动态的，不需要去为他设置长度。</p><h4 id="字符串常用属性方法"><a href="#字符串常用属性方法" class="headerlink" title="字符串常用属性方法"></a>字符串常用属性方法</h4><p>至于为什么字符串有方法，这点和JS中的包装类有关，大家课后可以自行去了解，目前大家只需要会用就可以了。</p><h5 id="获得字符串长度的length属性："><a href="#获得字符串长度的length属性：" class="headerlink" title="获得字符串长度的length属性："></a>获得字符串长度的length属性：</h5><p>使用字符串的length属性可以查看当前字符串中字符的数量，就算其中包括双字符也会按照单字符计算：<br>  <img src="/2024/03/06/js%E5%9F%BA%E7%A1%80/1.png" class=""><br>str长度按理来讲正常会为5，为6的原因是“😧”是进行增补过编码的字符，length属性按照16位码元作为一个字符去处理字符串，但是“😧”会占32位，所以他会被当成“😧”两个字符看待。</p><h5 id="拼接字符串的concat方法"><a href="#拼接字符串的concat方法" class="headerlink" title="拼接字符串的concat方法"></a>拼接字符串的concat方法</h5><p>concat方法用于连接（合并&#x2F;拼接）字符串，使用方法为:</p><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs openscad"><span class="hljs-built_in">let</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-built_in">let</span> str2 = <span class="hljs-built_in">str</span>.<span class="hljs-built_in">concat</span>(<span class="hljs-string">&quot; world&quot;</span>, <span class="hljs-string">&quot; qwq&quot;</span>);<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">str</span>); <br>console.<span class="hljs-built_in">log</span>(str2); <br></code></pre></td></tr></table></figure><p>字符串也可以使用加运算符来拼接：</p><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs openscad"><span class="hljs-built_in">let</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot; world&quot;</span>;<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">str</span>); <span class="hljs-comment">// hello world</span><br></code></pre></td></tr></table></figure><div style="border: #e5b832 solid 2px; border-radius: 7px; background-color: antiquewhite; padding: 5px;">实际开发中更倾向于使用+运算符进行字符串拼接     </div>     <h5 id="字符串切片方法slice、substr、substring"><a href="#字符串切片方法slice、substr、substring" class="headerlink" title="字符串切片方法slice、substr、substring"></a>字符串切片方法slice、substr、substring</h5><p>切片方法，顾名思义，就是将字符串切成某一段的一片：<br>他接受两个参数，第一个参数是开始的位置（必传），第二个参数是结束的位置<br>当传入负数时，按照从末位开始算，-1表示倒数第一位</p><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs openscad"><span class="hljs-comment">//slice()</span><br><span class="hljs-built_in">let</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;一二三四五六七八&quot;</span>;<br><span class="hljs-built_in">let</span> strSplice = <span class="hljs-built_in">str</span>.slice(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>);<br>console.<span class="hljs-built_in">log</span>(strSplice);<span class="hljs-comment">//一二三四五六</span><br></code></pre></td></tr></table></figure><p><code> substr(startIndex, length)</code>方法接受两个参数，第一个参数指定从哪个位置开始截取字符串，第二个参数指定要截取的字符个数。例如：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;hello world!&quot;</span>;<br><span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Str</span> = str.substr(<span class="hljs-number">6</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 从第 6 个位置开始截取 5 个字符</span><br>console.log(<span class="hljs-keyword">new</span><span class="hljs-type">Str</span>); <span class="hljs-comment">// 输出 &quot;world&quot;</span><br></code></pre></td></tr></table></figure><div style="border: #e5b832 solid 2px; border-radius: 7px; background-color: antiquewhite; padding: 5px;">需要注意的是，如果第二个参数（即要截取的字符个数）缺省或为负数，则 substr() 方法将截取从第一个参数指定位置到字符串末尾的所有字符。     </div>     <p><code>substring(startIndex, endIndex)</code> 方法接受两个参数，第一个参数指定从哪个位置开始截取字符串，第二个参数指定要截取的最后一个字符所在位置的下标。例如：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;hello world!&quot;</span>;<br><span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Str</span> = str.substring(<span class="hljs-number">6</span>, <span class="hljs-number">11</span>); <span class="hljs-comment">// 从第 6 个位置开始截取到第 11 个位置（不包含第 11 个位置）</span><br>console.log(<span class="hljs-keyword">new</span><span class="hljs-type">Str</span>); <span class="hljs-comment">// 输出 &quot;world&quot;</span><br></code></pre></td></tr></table></figure><div style="border: #e5b832 solid 2px; border-radius: 7px; background-color: antiquewhite; padding: 5px;">需要注意的是，如果 substring() 方法的第一个参数大于第二个参数，则方法会自动交换这两个参数的位置，然后再执行截取操作。     </div>     <h5 id="删除左右空格的trim方法"><a href="#删除左右空格的trim方法" class="headerlink" title="删除左右空格的trim方法"></a>删除左右空格的trim方法</h5><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;   Hello World!   &quot;</span>;<br><span class="hljs-keyword">var</span> trimmedStr = str.<span class="hljs-built_in">trim</span>(); <span class="hljs-comment">// 去除字符串两端的空格</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(trimmedStr); <span class="hljs-comment">// 输出 &quot;Hello World!&quot;</span><br></code></pre></td></tr></table></figure><div style="border: #e5b832 solid 2px; border-radius: 7px; background-color: antiquewhite; padding: 5px;">需要注意的是，trim() 方法也不会改变原始字符串本身，而是返回一个新的字符串。因此，如果需要使用去除空格后的新字符串，请记得将其存储到一个变量中。     </div><h5 id="将字符串打碎成数组的split方法"><a href="#将字符串打碎成数组的split方法" class="headerlink" title="将字符串打碎成数组的split方法"></a>将字符串打碎成数组的split方法</h5><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">let str <span class="hljs-operator">=</span> <span class="hljs-string">&quot;一二三四五六七八&quot;</span><span class="hljs-comment">;</span><br>let engStr <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello world you qwq&quot;</span><span class="hljs-comment">;</span><br>console.log(str.split(<span class="hljs-string">&quot;&quot;</span>))<span class="hljs-comment">;</span><br>console.log(engStr.split(<span class="hljs-string">&quot; &quot;</span>))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h5 id="字符串的大小写转换方法toLowerCase-toUpperCase"><a href="#字符串的大小写转换方法toLowerCase-toUpperCase" class="headerlink" title="字符串的大小写转换方法toLowerCase toUpperCase"></a>字符串的大小写转换方法toLowerCase toUpperCase</h5><p><code>toLowerCase()</code>方法将字符串中所有的字母都转换为小写形式。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br><span class="hljs-keyword">var</span> lowerStr = str.toLowerCase(); <span class="hljs-comment">// 将字符串中的字母都转换为小写形式</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(lowerStr); <span class="hljs-comment">// 输出 &quot;hello world!&quot;</span><br></code></pre></td></tr></table></figure><p><code>toUpperCase()</code>方法将字符串中所有的字母都转换为大写形式</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br><span class="hljs-keyword">var</span> upperStr = str.toUpperCase(); <span class="hljs-comment">// 将字符串中的字母都转换为大写形式</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(upperStr); <span class="hljs-comment">// 输出 &quot;HELLO WORLD!&quot;</span><br></code></pre></td></tr></table></figure><div style="border: #e5b832 solid 2px; border-radius: 7px; background-color: antiquewhite; padding: 5px;">toLowerCase()和toUpperCase() 方法并不会改变原始字符串本身，而是返回一个新的字符串。因此，如果需要使用新的字符串，请记得将其存储到一个变量中。     </div>     <h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组是什么"><a href="#数组是什么" class="headerlink" title="数组是什么"></a>数组是什么</h4><p>数组和上面所说的字符串不一样，他是一种复杂的数据类型，存储在堆中。<br>在JS的数组中，可以任意的存放各种类型的数据（这点和大多数其他语言不同），并且JS的数组是动态的，他会自动为你扩充大小。</p><div style="border: #e5b832 solid 2px; border-radius: 7px; background-color: antiquewhite; padding: 5px;">在开发中，数组有时候也会存入一系列对象，这在JS中是被允许的，而且也会有遍历的方法，详见下文     </div>     <h4 id="如何访问数组？"><a href="#如何访问数组？" class="headerlink" title="如何访问数组？"></a>如何访问数组？</h4><p>与C语言类似，JS的数组也是通过[ ]进行访问的，索引值0依旧代表第一个元素，以此类推。</p><h4 id="检查数组长度的length属性"><a href="#检查数组长度的length属性" class="headerlink" title="检查数组长度的length属性"></a>检查数组长度的length属性</h4><p>和字符串的属性类似，数组会有一个length属性供我们查看数组中有多少个元素。</p><div style="border: #e5b832 solid 2px; border-radius: 7px; background-color: antiquewhite; padding: 5px;">虽然到这里大家很容易就可以想到可以使用for循环和length属性遍历数组中的元素，但请先不要这样做，下面会有更好的方式去遍历数组。     </div>    <h4 id="转换数组为字符串的join方法"><a href="#转换数组为字符串的join方法" class="headerlink" title="转换数组为字符串的join方法"></a>转换数组为字符串的join方法</h4><p>其实在JS中，数组也是一种特殊的对象，所有对象都会拥有toString方法用于返回一个和该对象有关的字符串，数组也不例外，他可以返回一个用逗号相连的字符串。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;qwq&quot;</span>];<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr.toString());<span class="hljs-comment">//a,b,1,2,qwq</span><br></code></pre></td></tr></table></figure><p>使用join方法可以直接返回一个以传入参数为分隔连接起来的字符串</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;qwq&quot;</span>];<br>console.<span class="hljs-built_in">log</span>(arr.<span class="hljs-built_in">join</span>(<span class="hljs-string">&quot;&quot;</span>));<br></code></pre></td></tr></table></figure><div style="border: #e5b832 solid 2px; border-radius: 7px; background-color: antiquewhite; padding: 5px;">不推荐使用toString方法，因为toString方法在任何对象（包括各种数组以外的对象）join方法相对更好用。     </div><h4 id="数组的推入与删除push-pop-shift-unshift"><a href="#数组的推入与删除push-pop-shift-unshift" class="headerlink" title="数组的推入与删除push pop shift unshift"></a>数组的推入与删除push pop shift unshift</h4><p>使用push pop shift unshift方法可以操作数组最前面一项和最后面一项<br>push：向数组的最后推入一项<br>pop：移除数组的最后一项<br>shift：移除数组的第一项<br>unshift：向数组最前方推入一项</p><h5 id="push和pop方法可以构建类似栈的处理方式"><a href="#push和pop方法可以构建类似栈的处理方式" class="headerlink" title="push和pop方法可以构建类似栈的处理方式"></a>push和pop方法可以构建类似栈的处理方式</h5><p>使用push向末尾推入新的一项，用pop删除最后一项，这样的操作方式和栈的工作原理一致(类似于摞书，后进先出)</p><h5 id="shift和push方法可以构建类似队列的处理方式"><a href="#shift和push方法可以构建类似队列的处理方式" class="headerlink" title="shift和push方法可以构建类似队列的处理方式"></a>shift和push方法可以构建类似队列的处理方式</h5><p>使用shift和push方法可以构建类似队列的处理方式，使用push推入最后一项，使用shift删除最前面的一项。（类似于排队，先进先出）</p><h4 id="数组的迭代方法map，forEach"><a href="#数组的迭代方法map，forEach" class="headerlink" title="数组的迭代方法map，forEach"></a>数组的迭代方法map，forEach</h4><h5 id="forEach方法-不带返回值"><a href="#forEach方法-不带返回值" class="headerlink" title="forEach方法(不带返回值):"></a>forEach方法(不带返回值):</h5><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br>arr.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(item);<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="map方法-有返回值，返回值为一个新数组"><a href="#map方法-有返回值，返回值为一个新数组" class="headerlink" title="map方法(有返回值，返回值为一个新数组):"></a>map方法(有返回值，返回值为一个新数组):</h5><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br>let arrNew = arr.<span class="hljs-built_in">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> item + <span class="hljs-number">1</span>;<br>&#125;);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arrNew);<br></code></pre></td></tr></table></figure><p>并且，map方法可以方便进行链式调用</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br>let arrNew = arr<br>  .<span class="hljs-built_in">map</span>(<span class="hljs-function">(<span class="hljs-params">item，index</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> item + <span class="hljs-number">1</span>;<br>  &#125;)<br>  .<span class="hljs-built_in">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> item &gt; <span class="hljs-number">2</span> ? item : <span class="hljs-literal">undefined</span>;<br>  &#125;);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arrNew);<br></code></pre></td></tr></table></figure><h4 id="数组的过滤方法filter"><a href="#数组的过滤方法filter" class="headerlink" title="数组的过滤方法filter"></a>数组的过滤方法filter</h4><p><code>filter方法</code>用于对数组进行过滤。它会创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br><span class="hljs-keyword">var</span> result = arr.<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">number</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">number</span> &gt; <span class="hljs-number">3</span><br>&#125;)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result);<span class="hljs-comment">//5,6</span><br></code></pre></td></tr></table></figure><h4 id="数组中查找某个元素的位置indexOf"><a href="#数组中查找某个元素的位置indexOf" class="headerlink" title="数组中查找某个元素的位置indexOf"></a>数组中查找某个元素的位置indexOf</h4><p><code>array.indexOf(item,start)</code>方法可返回数组中某个指定的元素位置。该方法将从头到尾地检索数组，看它是否含有对应的元素。开始检索的位置在数组 start 处或数组的开头（没有指定 start 参数时）。如果找到一个 item，则返回 item 的第一次出现的位置。如果在数组中没找到指定元素则返回 -1。</p><figure class="highlight flix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs flix"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">index</span> = fruits.indexOf(<span class="hljs-string">&quot;Apple&quot;</span>);<br>console.log(<span class="hljs-keyword">index</span>);<br></code></pre></td></tr></table></figure><h4 id="翻转数组reverse"><a href="#翻转数组reverse" class="headerlink" title="翻转数组reverse()"></a>翻转数组reverse()</h4><p><code>reverse()</code> 方法会原地反转数组元素的顺序。即将数组中的第一个元素变为最后一个元素，第二个元素变为倒数第二个元素，依此类推。该方法不会创建一个新的数组，而是直接修改原数组。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>arr.<span class="hljs-built_in">reverse</span>();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr); <span class="hljs-comment">// 输出：[5, 4, 3, 2, 1]</span><br></code></pre></td></tr></table></figure><h4 id="排序方法sort"><a href="#排序方法sort" class="headerlink" title="排序方法sort()"></a>排序方法sort()</h4><p><code>sort()</code>方法用于对数组进行排序，默认情况下按照 Unicode 编码进行排序。该方法会原地修改数组，将其按照指定的排序顺序重新排列。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const arr = [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>];<br>arr.<span class="hljs-built_in">sort</span>();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr); <span class="hljs-comment">// 输出：[1, 2, 3, 4, 5]ß</span><br></code></pre></td></tr></table></figure><p>在上述代码中，我们调用 sort() 方法对数组 arr 进行排序，结果是按照升序排列的数组。<br>如果需要自定义排序规则，可以通过传入一个比较函数作为参数来实现。比较函数应返回一个负数、零或正数，分别表示第一个参数小于、等于或大于第二个参数。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const arr = [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>];<br>arr.<span class="hljs-built_in">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr); <span class="hljs-comment">// 输出：[1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure><h4 id="截取数组splice"><a href="#截取数组splice" class="headerlink" title="截取数组splice()"></a>截取数组splice()</h4><p><code>splice()</code>是一个用于修改数组的方法。它可以删除现有元素、添加新元素或替换现有元素。splice() 方法可以接受多个参数，主要包括：<br>起始索引(必需)：指定修改的起始位置。<br>要删除的元素个数（可选）：指定要删除的元素数量。<br>要添加到数组的元素（可选）：可以添加一个或多个元素到数组中。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">let fruits = [<span class="hljs-string">&#x27;apple&#x27;</span>,<span class="hljs-string">&#x27;banana&#x27;</span>,<span class="hljs-string">&#x27;cherry&#x27;</span>,<span class="hljs-string">&#x27;date&#x27;</span>];<br><br><span class="hljs-regexp">//</span> 从索引为 <span class="hljs-number">2</span> 的位置开始删除 <span class="hljs-number">1</span> 个元素<br>fruits.splice(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>); <span class="hljs-regexp">//</span> fruits变为[<span class="hljs-string">&#x27;apple&#x27;</span>,<span class="hljs-string">&#x27;banana&#x27;</span>,<span class="hljs-string">&#x27;date&#x27;</span>]<br><br><span class="hljs-regexp">//</span> 从索引为 <span class="hljs-number">1</span> 的位置开始删除 <span class="hljs-number">2</span> 个元素,并添加<span class="hljs-string">&#x27;orange&#x27;</span>和<span class="hljs-string">&#x27;peach&#x27;</span><br>fruits.splice(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;peach&#x27;</span>); <span class="hljs-regexp">//</span> fruits变为[<span class="hljs-string">&#x27;apple&#x27;</span>,<span class="hljs-string">&#x27;orange&#x27;</span>,<span class="hljs-string">&#x27;peach&#x27;</span>]<br><br><span class="hljs-regexp">//</span> 从索引为 <span class="hljs-number">2</span> 的位置开始不删除元素，但添加 <span class="hljs-string">&#x27;kiwi&#x27;</span> 和 <span class="hljs-string">&#x27;lemon&#x27;</span><br>fruits.splice(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;kiwi&#x27;</span>, <span class="hljs-string">&#x27;lemon&#x27;</span>); <span class="hljs-regexp">//</span> fruits变为[<span class="hljs-string">&#x27;apple&#x27;</span>,<span class="hljs-string">&#x27;orange&#x27;</span>,<span class="hljs-string">&#x27;kiwi&#x27;</span>,<span class="hljs-string">&#x27;lemon&#x27;</span>,<span class="hljs-string">&#x27;peach&#x27;</span>]<br></code></pre></td></tr></table></figure><h3 id="ES6新增语法"><a href="#ES6新增语法" class="headerlink" title="ES6新增语法"></a>ES6新增语法</h3><h4 id="1-解构赋值"><a href="#1-解构赋值" class="headerlink" title="1.解构赋值"></a>1.解构赋值</h4><p><strong>定义</strong>：允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。ES6中允许从数组中提取值，按照对应位置，对变量赋值，对象也可以实现解构</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>&#125;<br><span class="hljs-keyword">var</span> tmp = foo(),<br>a = tmp[<span class="hljs-number">0</span>], b = tmp[<span class="hljs-number">1</span>], c = tmp[<span class="hljs-number">2</span>];<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a, b, c);<br></code></pre></td></tr></table></figure><p>上例可以看到，我们进行一个手动赋值，把foo()返回数组中的值赋给独立变量a,b,c ，为了实现这一点我们需要一个临时变量<code>tmp</code>。</p><h5 id="1-数组解构"><a href="#1-数组解构" class="headerlink" title="1)数组解构"></a>1)数组解构</h5><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let [a, b, c，d] = foo();<br> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a)<span class="hljs-comment">//1</span><br> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(b)<span class="hljs-comment">//2</span><br> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(c)<span class="hljs-comment">//3</span><br><span class="hljs-comment">//如果解构不成功，变量的值为undefined</span><br></code></pre></td></tr></table></figure><h5 id="2-对象解构"><a href="#2-对象解构" class="headerlink" title="2)对象解构"></a>2)对象解构</h5><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">let person = &#123; <span class="hljs-keyword">name</span>: <span class="hljs-string">&#x27;zhangsan&#x27;</span>, age: <span class="hljs-number">20</span> &#125;; <br> let &#123; <span class="hljs-keyword">name</span>, age &#125; = person;<br> console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">name</span>); <span class="hljs-comment">// &#x27;zhangsan&#x27; </span><br> console.<span class="hljs-built_in">log</span>(age); <span class="hljs-comment">// 20</span><br><span class="hljs-comment">//注意：对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；</span><br><span class="hljs-comment">//而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</span><br></code></pre></td></tr></table></figure><p>我们还可以指定其他的属性名</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let &#123;<span class="hljs-attr">name</span>: myName, <span class="hljs-attr">age</span>: myAge&#125; = person; <span class="hljs-comment">// myName myAge 属于别名</span><br> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(myName); <span class="hljs-comment">// &#x27;zhangsan&#x27; </span><br> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(myAge); <span class="hljs-comment">// 20</span><br></code></pre></td></tr></table></figure><p>这实际上说明，对象的解构赋值是下面形式的简写</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-keyword">return</span> &#123;<br>           <span class="hljs-attr">x</span>: <span class="hljs-number">4</span>,<br>           <span class="hljs-attr">y</span>: <span class="hljs-number">5</span>,<br>           <span class="hljs-attr">z</span>: <span class="hljs-number">6</span><br>       &#125;;<br>   &#125;<br>   <span class="hljs-keyword">var</span> &#123; <span class="hljs-attr">x</span>: x, <span class="hljs-attr">y</span>: y, <span class="hljs-attr">z</span>: z &#125; = bar();<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x, y, z);<br></code></pre></td></tr></table></figure><div style="border: #e5b832 solid 2px; border-radius: 7px; background-color: antiquewhite; padding: 5px;">如果属性名和要赋值的变量名相同，这种语法可以更简短一些     </div><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-keyword">return</span> &#123;<br>           <span class="hljs-attr">x</span>: <span class="hljs-number">4</span>,<br>           <span class="hljs-attr">y</span>: <span class="hljs-number">5</span>,<br>           <span class="hljs-attr">z</span>: <span class="hljs-number">6</span><br>       &#125;;<br>   &#125;<br>   <span class="hljs-keyword">var</span> &#123; x, y, z &#125; = bar();<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x, y, z);<br></code></pre></td></tr></table></figure><h5 id="3-小结"><a href="#3-小结" class="headerlink" title="3)小结"></a>3)小结</h5><ul><li>解构赋值就是把数据解构分解，然后给变量进行赋值</li><li>如果解构不成功，变量跟数值个数不匹配的时候，变量的值为<code>undefined</code></li><li>数组解构用中括号包裹，多个变量用逗号隔开，对象解构用花括号包裹，多个变量用逗号隔开</li><li>利用解构赋值能够让我们方便的去取对象的属性跟方法</li><li>以上只是一些基本的用法，我们还可以在解构的同时指定参数的默认值，对数组对象进行多次解构等</li></ul><h4 id="2-对象字面量"><a href="#2-对象字面量" class="headerlink" title="2.对象字面量"></a>2.对象字面量</h4><h5 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h5><p>ES6允许对象的属性直接写变量，这时候属性名是变量名，属性值是变量值。在大括号里面，就可以直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">const age</span> = 12;<br><span class="hljs-attribute">const name</span> = <span class="hljs-string">&quot;Amy&quot;</span>;<br><span class="hljs-attribute">const person</span> = &#123;age, name&#125;;<br></code></pre></td></tr></table></figure><p> 方法名也可以简写<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hi&quot;</span>);<br>  &#125;<br>&#125;<br>person.<span class="hljs-title function_">sayHi</span>();  <span class="hljs-comment">//&quot;Hi&quot;</span><br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">sayHi</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hi&quot;</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><h5 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h5><p>ES6允许用表达式作为属性名，但是一定要将表达式放在方括号内。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">const</span> obj = &#123;<br> [<span class="hljs-string">&quot;he&quot;</span>+<span class="hljs-string">&quot;llo&quot;</span>]()&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hi&quot;</span>;<br>  &#125;<br>&#125;<br>obj.hello();  <span class="hljs-comment">//&quot;Hi&quot;</span><br></code></pre></td></tr></table></figure><div style="border: #e5b832 solid 2px; border-radius: 7px; background-color: antiquewhite; padding: 5px;">注意：属性的简洁表示法和属性名表达式不能同时使用，否则会报错。     </div><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs openscad"><span class="hljs-built_in">let</span> <span class="hljs-built_in">str</span> = &#x27;hello&#x27;<br>   <span class="hljs-built_in">let</span> obj = &#123; [<span class="hljs-built_in">str</span>] &#125;<span class="hljs-comment">//报错</span><br>   console.<span class="hljs-built_in">log</span>(obj);<br></code></pre></td></tr></table></figure><h4 id="3-对象的拓展运算符"><a href="#3-对象的拓展运算符" class="headerlink" title="3.对象的拓展运算符"></a>3.对象的拓展运算符</h4><p>拓展运算符（…）用于取出参数对象所有可遍历属性然后拷贝到当前对象。<br>基本用法</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">let</span> person = &#123;name: <span class="hljs-string">&quot;Amy&quot;</span>, age: <span class="hljs-number">15</span> &#125;;<br><span class="hljs-keyword">let</span> someone = &#123; <span class="hljs-params">...</span>person &#125;;<span class="hljs-comment">//此时someone与person所含键值对相同</span><br></code></pre></td></tr></table></figure><p>可用于合并两个对象</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">let</span> age = &#123;age: <span class="hljs-number">15</span>&#125;;<br><span class="hljs-keyword">let</span><span class="hljs-built_in"> name</span> = <span class="hljs-built_in">&#123;name</span>: <span class="hljs-string">&quot;Amy&quot;</span>&#125;;<br><span class="hljs-keyword">let</span> person = &#123;...age, ..<span class="hljs-built_in">.name</span>&#125;;<br></code></pre></td></tr></table></figure><h4 id="set对象"><a href="#set对象" class="headerlink" title="set对象"></a>set对象</h4><p>Set 对象是 JavaScript 中的一种数据结构，用于存储唯一的值。它类似于数组，但是与数组不同的是，Set 中的元素是唯一的，不会出现重复值。<br>下面是一些 Set 对象的特点：</p><ol><li>唯一性：Set 中的元素是唯一的，重复的元素只会保留一个副本。</li><li>无序性：Set 中的元素没有固定的顺序，不像数组有索引来访问元素。</li><li>可迭代性：可以通过迭代器遍历 Set 中的元素。</li><li>高效性：Set 提供了高效的添加、删除和查找元素的操作。</li></ol><p><strong>可以使用 add() 方法向 Set 对象中添加元素，使用 delete() 方法删除元素，使用 has() 方法检查元素是否存在，使用 clear() 方法清空 Set 对象中的所有元素。</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const mySet = <span class="hljs-keyword">new</span> Set();<br>mySet.add(<span class="hljs-string">&quot;apple&quot;</span>); <span class="hljs-comment">// </span><br>mySet.add(<span class="hljs-string">&quot;banana&quot;</span>);<br>mySet.add(<span class="hljs-string">&quot;orange&quot;</span>);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(mySet.size); <span class="hljs-comment">// 输出: 3</span><br><br>mySet.delete(<span class="hljs-string">&quot;banana&quot;</span>);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(mySet.has(<span class="hljs-string">&quot;apple&quot;</span>)); <span class="hljs-comment">// 输出: true</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(mySet.has(<span class="hljs-string">&quot;banana&quot;</span>)); <span class="hljs-comment">// 输出: false</span><br><br>mySet.forEach(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(value);<br>&#125;);<br><span class="hljs-comment">// 输出:</span><br><span class="hljs-comment">// apple</span><br><span class="hljs-comment">// orange</span><br></code></pre></td></tr></table></figure><h4 id="map对象"><a href="#map对象" class="headerlink" title="map对象"></a>map对象</h4><p>Map是一种集合类型，它提供了一种将键值对存储为映射关系的方式。相比于普通的对象，Map 对象具有以下优势和用途：<br>任意类型的键：在Map对象中，键可以是任意数据类型，包括基本类型、对象、函数等。而在普通对象中，键只能是字符串或符号。</p><ol><li><p><strong>顺序迭代</strong>：Map对象会按照插入的顺序保留键值对，因此可以通过迭代器按照插入顺序遍历 Map 中的元素。</p></li><li><p><strong>快速查找</strong>：使用 Map对象可以快速查找特定键的值，而不需要进行线性搜索，相比较普通对象的属性查找效率更高。</p></li><li><p><strong>键的唯一性</strong>：Map对象中的键是唯一的，不会出现重复键。如果使用相同的键进行多次设置，则后续的设置会覆盖前面的设置。</p></li><li><p><strong>可迭代性</strong>：Map对象是可迭代的，可以使用 for…of 或 forEach() 方法遍历 Map 中的键值对。</p></li><li><p><strong>灵活性</strong>：Map对象提供了丰富的方法和属性，例如 set()、get()、has()、delete() 等，以及 size 属性用于获取 Map 中键值对的数量。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 创建一个 Map 对象</span><br>const myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br><br><span class="hljs-comment">// 设置键值对</span><br>myMap.set(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>);<br>myMap.set(<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">25</span>);<br>myMap.set(<span class="hljs-string">&#x27;city&#x27;</span>, <span class="hljs-string">&#x27;Beijing&#x27;</span>);<br><br><span class="hljs-comment">// 获取值</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(myMap.get(<span class="hljs-string">&#x27;name&#x27;</span>)); <span class="hljs-comment">// 输出: Alice</span><br><br><span class="hljs-comment">// 检查键是否存在</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(myMap.has(<span class="hljs-string">&#x27;age&#x27;</span>)); <span class="hljs-comment">// 输出: true</span><br><br><span class="hljs-comment">// 获取 Map 中的键的数量</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(myMap.size); <span class="hljs-comment">// 输出: 3</span><br><br><span class="hljs-comment">// 遍历 Map</span><br>myMap.forEach(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>: <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>&#125;);<br><span class="hljs-comment">// 输出:</span><br><span class="hljs-comment">// name: Alice</span><br><span class="hljs-comment">// age: 25</span><br><span class="hljs-comment">// city: Beijing</span><br><br><span class="hljs-comment">// 使用迭代器遍历 Map</span><br><span class="hljs-keyword">for</span> (const [key, value] of myMap) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>: <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>&#125;<br><span class="hljs-comment">// 输出:</span><br><span class="hljs-comment">// name: Alice</span><br><span class="hljs-comment">// age: 25</span><br><span class="hljs-comment">// city: Beijing</span><br><br><span class="hljs-comment">// 删除键值对</span><br>myMap.delete(<span class="hljs-string">&#x27;age&#x27;</span>);<br><br><span class="hljs-comment">// 清空 Map</span><br>myMap.clear();<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS</title>
    <link href="/2024/02/29/CSS/"/>
    <url>/2024/02/29/CSS/</url>
    
    <content type="html"><![CDATA[<h2 id="section9">一.CSS选择器的概念</h2>    <br>    <p>CSS选择器，是元素和其他部分组合起来告诉浏览器哪个 HTML 元素应当是被选为应用规则中的 CSS 属性值的方式。</p>    <br>    <div style="border: 3px solid gold;">        <ol>            <li>通配选择器，由一个星号（*）代指它选中了文档中的所有内容。</li>            <li>类型选择器，也叫标签名选择器或者是元素选择器，它在文档中选择了一个 HTML 标签/元素</li>            <li>类选择器，以一个句点（.）开头，会选择文档中应用了这个类的所有物件。</li>            <li>id选择器，开头为#而非句点，不过基本上和类选择器是同种用法。一个 ID 只会一般用到一次，虽然用多次也能正常显示，但是用javascript通过id来控制元素时就会出现错误。</li>        </ol>    </div>   <img src="/2024/02/29/CSS/1_%E5%89%AF%E6%9C%AC.png" class="">    <p>层叠是 CSS 的一个基本特征，意为多个选择符之间具有特定的优先级，它是一个定义了如何合并来自多个源的属性值的算法。</p>    <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br><span class="hljs-attribute">color</span>:red;<br>&#125;<br>      <br><span class="hljs-selector-tag">p</span>&#123;<br><span class="hljs-attribute">color</span>:bule;<br>&#125;<br></code></pre></td></tr></table></figure>    <div>在上面的代码块中，我们为p选择器定义了两个规则，但是段落最后是蓝色的。这是因为将其设置为蓝色的声明将出现在样式表的后面，而稍后的样式将覆盖以前的样式。</div>    <br>    <div>这是在同样优先级的情况下，如果在优先级不同时，</div>    <br>    <div>比如，在我们同时使用了类选择器和元素选择器的前一个例子中，类将获胜，使得段落变红——即使它出现在样式表的前面。</div>    <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.special</span>&#123;<br><span class="hljs-attribute">color</span>:aqua;<br>&#125;<br>       <br><span class="hljs-selector-tag">p</span>&#123;<br><span class="hljs-attribute">color</span>:black;<br>&#125;<br></code></pre></td></tr></table></figure>    <div>所以，在同优先级的情况下，后定义的生效，不同级则优先级高的生效。</div>    <br>    <div>各优先级关系，一般来说，选择器的优先级，范围越小，优先级越高</div>    <br>    <div>id选择器 > 类选择器 > 元素选择器 > 通配符选择器</div>      <img src="/2024/02/29/CSS/2_%E5%89%AF%E6%9C%AC.png" class="">    <h2 id="section10">二.CSS基本样式</h2>    <br>    <h3>常用样式</h3>    <h4>1.font-size:字体大小px</h4>    <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-weight</span>:normal;//字体粗细<br><span class="hljs-attribute">font-style</span>:italic;//字体倾斜<br></code></pre></td></tr></table></figure>    <br>    <h4>2.text-align:center;//文本对齐</h4>       <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">text-decoration</span>: none; //无装饰<br> <span class="hljs-attribute">text-decoration</span>: overline; //上划线<br> <span class="hljs-attribute">text-decoration</span>: line-through; //中划线<br> <span class="hljs-attribute">text-decoration</span>: underline; //下划线<br> <span class="hljs-attribute">text-transform</span>: uppercase; //文本转换，全部换为大写字母<br> <span class="hljs-attribute">text-indent</span>: <span class="hljs-number">50px</span>; //首行缩进<br><span class="hljs-attribute">letter-spacing</span>: <span class="hljs-number">3px</span>; //字母间距<br> <span class="hljs-attribute">word-spacing</span>: <span class="hljs-number">10px</span>; //单词间距<br> <span class="hljs-attribute">line-height</span>: <span class="hljs-number">0.8</span>; //行间距<br> <span class="hljs-attribute">white-space</span>: nowrap; //禁用<span class="hljs-selector-tag">html</span>框中文字编辑时的换行符（不必懂）<br> <span class="hljs-attribute">text-shadow</span>: <span class="hljs-number">2px</span> <span class="hljs-number">2px</span> <span class="hljs-number">5px</span> red;//分别是文本的水平、垂直阴影以及阴影的模糊效果、阴影颜色<br></code></pre></td></tr></table></figure>    <h4>3.color:字体颜色</h4>        <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css">使用 <span class="hljs-attribute">color</span> 属性：可以直接为元素指定 <span class="hljs-attribute">color</span> 属性来设置字体颜色<br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br><br>使用 RGB 值：可以使用 RGB 值来指定颜色<br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <br>&#125;<br><br>使用十六进制值：也可以使用十六进制值来指定颜色<br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#ff0000</span>; <br>&#125;<br></code></pre></td></tr></table></figure>    <br>    <h4>4.background:背景样式</h4>           <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-color</span>: blue; //颜色名称方式<br><span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); //RGB方式<br><span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>; //十六进制方式<br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;bg.png&quot;</span>) ; //设置背景图片<br><span class="hljs-attribute">background-size</span>: contain/cover; // 图片相对于盒子的尺寸<br><span class="hljs-attribute">background-repeat</span>: repeat-x; //沿x方向阵列<br><span class="hljs-attribute">background-position</span>: right top; //设置背景图片初始位置<br><span class="hljs-attribute">background-attachment</span>: fixed; //背景图片是否随网页滑动<br><span class="hljs-attribute">background</span>: <span class="hljs-number">#ffffff</span> <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;tree.png&quot;</span>) no-repeat right top;//简写形式<br></code></pre></td></tr></table></figure>    <br>    <h4>5.height,width,margin,padding、border</h4>      <img src="/2024/02/29/CSS/3_%E5%89%AF%E6%9C%AC.png" class="">            <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">width</span>:<span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">border-style</span>: solid; // 边框样式<br>    <span class="hljs-attribute">border-color</span>: <span class="hljs-number">#ccc</span>; // 边框颜色<br>    <span class="hljs-attribute">border-width</span>: <span class="hljs-number">15px</span>; // 边框宽度<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>; //允许你设置元素的外边框圆角,该属性是将这四个属性<span class="hljs-attribute">border-top-left-radius</span>,<span class="hljs-attribute">border-top-right-radius</span>,<span class="hljs-attribute">border-bottom-right-radius</span>,<span class="hljs-attribute">border-bottom-left-radius</span>简写为一个属性。<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">15px</span> solid green; //边框粗细 实线 颜色，dotted是点线，double是双线，dashed是虚线<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">50px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span>;<br>&#125;<br>   //<span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>; 设置内容的高度<br>   //<span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>; 设置内容的宽度<br></code></pre></td></tr></table></figure>    <h4>6.outline-style:轮廓样式</h4>            <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">outline-color</span>: red; //轮廓颜色<br><span class="hljs-attribute">outline-style</span>: dotted; //轮廓样式<br><span class="hljs-attribute">outline-width</span>: thin; 轮廓宽度<br><span class="hljs-attribute">outline</span>: <span class="hljs-number">5px</span> solid yellow; 简写轮廓属性<br>&lt;<span class="hljs-attribute">outline-offset</span>: <span class="hljs-number">25px</span>;//轮廓偏移<br></code></pre></td></tr></table></figure>    <h4>7.轮廓（outline）与边框（border）的区别：</h4> <div style="border: 3px solid rgb(253, 232, 179);">        <ol type="a">            <li>border 可应用于几乎所有有形的 html 元素，而 outline 是针对链接、表单控件等元素设计。</li>            <li>outline 的效果将随元素的 focus 而自动出现(除非手动设置outline-style)，相应的由 blur（blur事件，即指元素失去焦点） 而自动消失。这些都是浏览器的默认行为，无需JavaScript 配合 CSS 来控制。</li>            <li>outline 是不占空间的，不会像 border 那样影响元素的尺寸或者位置，既不会增加额外的 width 或者 height</li>            <li>对于input之类的表单控件，当你手动设置outline-style，它将不会采用默认的触发方式，而是直接显示，在没有手动设置outline-style的情况下，outline-width不生效</li>        </ol>    </div>     <h4>7.cursor的常用方法</h4>     <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">auto：浏览器自动决定合适的光标。<br>default：默认光标，通常是一个箭头。<br>pointer：手形光标，表示链接。<br>help：帮助光标，通常是一个问号。<br>wait：等待光标，表示正在加载或处理中。<br>text：文本光标，表示可编辑文本。<br>move：移动光标，表示可移动对象。<br>not-allowed：禁止操作光标，表示不允许点击或操作。<br></code></pre></td></tr></table></figure>    <h2 id="section11">三.CSS伪元素和伪类</h2>    <h3>什么是伪类？</h3>    <div>伪类是选择器的一种，它用于选择处于特定状态的元素。</div>    <h4>语法</h4>    <div>伪类就是开头为冒号的关键字：</div>    <figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">selector:pseudo-<span class="hljs-keyword">class</span>-<span class="hljs-keyword">name</span><span class="hljs-comment">&#123;&#125;</span><br></code></pre></td></tr></table></figure>    <h4>常见伪类</h4>    <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-comment">/* 在用户将指针挪到元素上的时候才会激活 */</span><br><span class="hljs-selector-pseudo">:focus</span> <span class="hljs-comment">/* 获得焦点的元素激活 */</span><br><span class="hljs-selector-pseudo">:active</span> <span class="hljs-comment">/* 当元素被激活（例如，当按钮被点击并保持按下状态）时应用样式。*/</span><br></code></pre></td></tr></table></figure>    <h3>什么是伪元素？</h3>    <div>伪元素是一个附加至选择器末的关键词，允许你对被选择元素的特定部分修改样式。</div>    <h4>语法</h4>    <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">selector:</span>:<span class="hljs-title class_">pseudo-element</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">          property:</span> <span class="hljs-attr">value</span><span class="hljs-punctuation">;</span><br>  <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>    <h4>常见伪元素</h4>    <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">::after</span> <span class="hljs-comment">/* 用来创建一个伪元素，作为已选中元素的最后一个子元素,通常会配合content属性来为该元素添加装饰内容。这个虚拟元素默认是行内元素 */</span><br><span class="hljs-selector-pseudo">::before</span> <span class="hljs-comment">/* 用来创建一个伪元素，作为已选中元素的第一个子元素，其余同上 */</span><br><span class="hljs-attribute">content</span> <span class="hljs-comment">/* 用于在元素的 ::before 和 ::after 伪元素中插入内容 */</span><br></code></pre></td></tr></table></figure>    <h3>html与css的结合方式</h3>    <ol>        <li>行内式：html中的标签属性 style ：适用于单纯只有一个标签需要设置时的特殊样式。如果多个标签需要应用同一个样式，建议采用内嵌式。</li>          <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: blue;background-color: yellow;border: 1px solid black;&quot;</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure>        <li>内嵌式：建议在head中使用，使用标签 style 适用于当前页面多个标签使用同一个样式。</li>        <li>外链式：link:适用于多个页面使用同一个样式时。</li>    </ol>    <div style="text-align:left;"><strong>注意：link中href属性必须有，表示链接的css文件。</strong></div>   ]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浏览器运行原理</title>
    <link href="/2024/02/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <url>/2024/02/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[ <h2>浏览器运行原理</h2>    <br>    <h3 id="section1">1.浏览器简化结构图</h3> <img src="/2024/02/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/%E7%BB%93%E6%9E%84%E5%9B%BE.png" class="">    <br>    <h3 id="section2">2.浏览器内核</h3>    <br>    <ul type="square">        <li>常见浏览器:IE、Edge、Firefox、Chrome、Safari、Opera</li>        <li>浏览器内核分成两部分：渲染引擎和JS引擎</li>        <li type="circle">渲染引擎:对HTML文档进行解析并将其显示在页面上的工具</li>        <li type="circle">由于js引擎越来越独立，内核就倾向于只指渲染引擎</li>    </ul>  <img src="/2024/02/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8.png" class="">    <h3 id="section3">3.浏览器是如何工作的</h3>    <br>    <p><strong>1.进程和线程</strong></p>    <p>进程是操作系统进行资源分配和调度的基本单元,可以申请和拥有计算机资源,进程是程序的基本执行实体。</p>    <p>线程是操作系统能够进行运算调度的最小单位,一个进程中可以并发多个线程,每条线程并行执行不同的任务。</p>    <img src="/2024/02/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/%E8%BF%9B%E7%A8%8B.png" class="">    <ul type="square">        <li>线程之间可以互相通信，交换数据</li>        <li>进程之间相对独立，并且内存也相对独立互不干扰</li>        <li>若进程之间需要相互通信，需要借用IPC（通信管道）</li>    </ul>    <br>    <p><strong>2.早期浏览器结构</strong></p>    <img src="/2024/02/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/%E6%97%A9%E6%9C%9F%E6%B5%8F%E8%A7%88%E5%99%A8.png" class="">    <ol>        <li style="color: chocolate;">不稳定 因为：其中一个线程的卡死可能会导致整个进程出问题，比如你打开一个标签页，其中一个标签页卡死可能会导致整个浏览器无法运行。</li>        <li style="color: chocolate;">不安全 因为：浏览器线程之间是可以共享数据的，那JS线程岂不是可以随意访问浏览器进程内的所有数据。</li>        <li style="color: chocolate;">不流畅 因为：一个进程需要负责太多事情，会导致运行效率问题。</li>    </ol>    <br>    <p><strong>3.现代浏览器结构</strong></p>    <img src="/2024/02/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/%E7%8E%B0%E4%BB%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%93%E6%9E%84.png" class="">    <ol type="i" style="background-color: blanchedalmond;">        <li>浏览器进程负责控制，Chrome浏览器除标签页外的用户界面，包括包括地址栏、书签、后退和前进按钮，以及负责与浏览器的其他进程协调工作。</li>        <li>网络进程负责发起接受网络请求</li>        <li>GPU进程负责整个浏览器界面的渲染</li>        <li>插件进程负责控制网站使用的所有插件，例如flash</li>        <li>渲染器进程用来控制显示tab标签内的所有内容</li>    </ol>    <br>    <h3 id="section4"><strong>4.在浏览器中搜索内容时，浏览器内部发生了什么</strong></h3>    <br>    <span>相关词释义：</span>    <ul style="font-family:cursive">        <li style="font-size: large;">DOM就是文档对象模型，是浏览器对页面在其内部的表示形式</li>        <li style="font-size: large;">layout树上的每个节点都记录了（X,Y）坐标和边框尺寸。</li>        <li style="font-size: large;">绘制记录表记录了会绘制的顺序（类似于图层）</li>        <li style="font-size: large;">Layer树是分层树，记录层级</li>        <li style="font-size: large;">draw quads是图块信息</li>    </ul>    <br>    <a href="https://gagjcxhxrb.feishu.cn/docx/VlWidsVZeoX8ySxACJRcN3P8njz?openbrd=1&doc_app_id=501&blockId=KINodiA1to1oLFxJUwbcONpynuf&blockType=whiteboard&blockToken=Rrotw6LkMhpnobbpATfcGnPYnWg#KINodiA1to1oLFxJUwbcONpynuf"        target="_blank">详细的浏览器内部进程</a>    <p style="font-size: larger;" style="font-weight: 600;">浏览器内部主要的进程</p>    <img src="/2024/02/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E5%99%A8.png" class="">    <p><strong>内部进程具体的过程</strong></p>    <div style="border: #e5b832 solid 2px;">        <ol>        <li>浏览器进程中的网络线程请求获取到html数据后，通过IPC将数据传给渲染器进程的主线程</li>        <li>数据在主线程中经过解析来构造DOM树</li>        <li>css代码进行样式计算，使得DOM树得各个节点拥有各自的样式</li>        <li>根据DOM树和省城好的样式生成器layout树</li>        <li>通过遍历Layout树生成绘制顺序表</li>        <li>接着遍历Layout树生成了Layer树</li>        <li>主线程将layer树和绘制顺序表的信息一起传给合成器线程</li>        <li>合成器线程分图层，并将图层分为更小的图块，将其传给栅格化线程</li>        <li>栅格化线程进行栅格化</li>        <li>栅格化完成后，合成器线程得到栅格化线程传过去的图块信息（drawquads）</li>        <li>根据图块信息，合成器线程合成一个合成器帧，然后将其通过IPC传回浏览器进程</li>        <li>浏览器进程再将合成器帧传到GPU进行渲染</li>    </ol>    </div>        <br>    <p>布局、绘制和JS执行都是在主线程运行的，当在一帧的时间内布局和绘制结束后，如果还有剩余时间，JS就会拿到主线程的使用权，进而解析和执行JS代码。</p>    <p>如果在一帧的时间内未能解析并执行完js代码，则会造成一帧的卡顿。并且在解析和执行完js代码后，使用权才会由js代码变为主线程</p>    <br>    <h3 id="section5"><strong>5.回流（重排）和重绘</strong></h3>    <p>重绘 （Redraw）：某些元素的外观被改变所触发的浏览器行为（重新计算节点在屏幕中的绝对位置并渲染的过程）。</p>    <p>例如：修改元素的填充颜色，会触发重绘。</p>    <p>回流（重排）（Reflow）：重新生成布局，重新排列元素（重新计算各节点和css具体的大小和位置：渲染树需要重新计算所有受影响的节点）。</p>    <p>例如：改元素的宽高，会触发重排。</p>    <h4>通过两者概念区别明显得知，重排要比重绘的成本大得多，我们应该尽量减少重排操作，减少页面性能消耗</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Html基础知识</title>
    <link href="/2024/02/28/Html%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/02/28/Html%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1-网页的构成"><a href="#1-网页的构成" class="headerlink" title="1.网页的构成"></a>1.网页的构成</h2><p>网页一般由三部分组成，分别是HTML（超文本标记语言）、CSS<strong>（层叠样式表）</strong>和JavaScript<strong>（简称“JS”动态脚本语言）</strong>，它们三者在网页中分别承担着不同的任务。</p><ul><li><strong>HTML 负责定义网页的内容</strong></li><li><strong>CSS 负责描述网页的布局</strong></li><li><strong>JavaScript负责网页的行为</strong></li></ul><h2 id="2-常用html元素"><a href="#2-常用html元素" class="headerlink" title="2.常用html元素"></a>2.常用html元素</h2><h4 id="标签标题"><a href="#标签标题" class="headerlink" title="标签标题"></a><strong>标签标题</strong></h4><p>作为标题使用，并且依据重要性递减（h1,h2….h6）</p><h4 id="换行标签和水平分割线标签"><a href="#换行标签和水平分割线标签" class="headerlink" title="换行标签和水平分割线标签"></a><strong>换行标签和水平分割线标签</strong></h4><ul><li>换行:&lt;br&#x2F;&gt;文本强制换行显示</li><li>水平分隔线：&lt;hr&#x2F;&gt; 插入水平分隔线</li></ul><h4 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a><strong>文本格式化标签</strong></h4><table><thead><tr><th align="left"><strong>加粗</strong></th><th align="center">&lt;strong&gt;&lt;&#x2F;strong&gt;</th><th align="right">&lt;b&gt;&lt;&#x2F;b&gt;</th></tr></thead><tbody><tr><td align="left"><strong>倾斜</strong></td><td align="center">&lt;em&gt;&lt;&#x2F;em&gt;</td><td align="right">&lt;i&gt;&lt;&#x2F;i&gt;</td></tr><tr><td align="left"><strong>删除线</strong></td><td align="center">&lt;del&gt;&lt;&#x2F;del&gt;</td><td align="right">&lt;s&gt;&lt;&#x2F;s&gt;</td></tr><tr><td align="left"><strong>下划线</strong></td><td align="center">&lt;ins&gt;&lt;&#x2F;ins&gt;</td><td align="right">&lt;u&gt;&lt;&#x2F;u&gt;</td></tr></tbody></table><h4 id="盒子标签"><a href="#盒子标签" class="headerlink" title="盒子标签"></a><strong>盒子标签</strong></h4><ul><li>&lt;div&gt;&lt;&#x2F;div&gt;一行只能放一个（块元素）</li><li>&lt;span&gt;&lt;&#x2F;span&gt;一行可以放多个（行内元素）</li></ul><h4 id="图像标签（单标签）"><a href="#图像标签（单标签）" class="headerlink" title="图像标签（单标签）"></a><strong>图像标签（单标签）</strong></h4><p>&lt;img&#x2F;&gt;</p><table><thead><tr><th align="left">属性</th><th align="center">属性值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="left">src</td><td align="center">图片</td><td align="center">必须属性</td></tr><tr><td align="left">alt</td><td align="center">文本</td><td align="center">替换文本。图像不能显示时的文字</td></tr><tr><td align="left">title</td><td align="center">文本</td><td align="center">提示文本。鼠标放到图像上，显示的文字</td></tr><tr><td align="left">width</td><td align="center">像素</td><td align="center">设置图像的宽度</td></tr><tr><td align="left">height</td><td align="center">像素</td><td align="center">设置图像的高度</td></tr><tr><td align="left">border</td><td align="center">像素</td><td align="center">设置图像的边框粗细</td></tr></tbody></table><h4 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h4><p><strong>&lt;a href&#x3D;”跳转目标” target&#x3D;”目标窗口的弹出方式”&gt;文本或图像</a></strong></p><h4 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a><strong>表格标签</strong></h4><p><strong>常用属性</strong></p><ul style="list-style-type: circle;"><li>border：表示表格的边框宽度，单位是像素，即px；</li><li> rowspan：表示多行合并，可以指定具体要合并的行数；(不要忘记删除多余的单元格)</li><li> colspan：表示多列合并，可以指定具体要合并的列数；(不要忘记删除多余的单元格)</li><li>  cellpadding：表示单元格边缘与其单元格内容之间的空白间距；</li><li>cellspacing：表示单元格之间的空白间距；</li><li>width：表示表格的宽度；</li><li>align：表示表格相对周围元素的对齐方式。</li></ul><h4 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h4><ul style="list-style-type: circle;"><li><strong>无序列表：使用&ltul>标签，里面放着&ltli>标签，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。&ltul>&lt/ul>中只能嵌套&ltli>标签&ltli>&lt/li>中可以放任何标签。</strong><p>type属性可以指定列表项的符号类型，如：disc（默认）：小圆点，circle：空心圆圈，square：方块</p></li><li><strong>使用&ltol>标签，里面放着&ltli>标签，列表项目使用数字进行标记&ltol>&lt/ol>中只能嵌套&ltli>标签</strong><p>type属性可以指定列表项的符号类型，如：i：罗马数字开始start属性，指定起始编号。</p></li><li><strong>自定义列表：使用&ltdl>标签，&ltdt>标签用来定义项目/名字，&ltdd>描述每一个项目/名字</strong><p>&ltdl>&lt/dl>只能包含&ltdt>和&ltdd></p></li></ul><h4 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a><strong>表单标签</strong></h4><p>标签的常用属性：</p><table><thead><tr><th align="left">属性</th><th align="center">属性值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="left">type</td><td align="center">见下表</td><td align="center">用于设置标签的不同形式</td></tr><tr><td align="left">value</td><td align="center">用户自定义</td><td align="center">设置input元素的默认值</td></tr></tbody></table><p>标签type属性值：</p><table><thead><tr><th align="left">属性值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="left">button</td><td align="center">定义可点击按钮</td></tr><tr><td align="left">checkbox</td><td align="center">定义复选框，一组复选框name属性必须相同</td></tr><tr><td align="left">password</td><td align="center">定义密码字段，该字段中的字符被掩码</td></tr><tr><td align="left">radio</td><td align="center">定义单选按钮，一组单选按钮的name属性值必须相同</td></tr><tr><td align="left">reset</td><td align="center">定义重置按钮，清除表单中的所有数据</td></tr><tr><td align="left">submit</td><td align="center">定义提交按钮，提交到action属性指定的地址</td></tr><tr><td align="left">text</td><td align="center">定义单行的输入字段，用户可在其中输入文本，默认宽度为20字符</td></tr></tbody></table><h2 id="分类（元素显示模式）"><a href="#分类（元素显示模式）" class="headerlink" title="分类（元素显示模式）"></a>分类（元素显示模式）</h2><table><thead><tr><th align="left">元素模式</th><th align="center">元素排列</th><th align="center">设置样式</th><th align="center">默认宽度</th><th align="center">包含</th></tr></thead><tbody><tr><td align="left">块级元素</td><td align="center">一行只能放一个</td><td align="center">可以设置宽度高度</td><td align="center">容器的100%</td><td align="center"><ul><li>标题标签：h1, h2, h3, h4, h5, h6</li><li>段落标签：p</li><li>换行标签：br</li><li>水平分隔符标签：hr</li><li>div</li><li>…</li></ul></td></tr><tr><td align="left">行内元素</td><td align="center">一行可以放多个</td><td align="center">不可以直接设置宽度高度</td><td align="center">它本身内容的宽度</td><td align="center"><ul><li>span</li><li>图像标签：img</li><li>文本格式化标签：i, em</li><li>输入标签：input</li><li>…</li></ul></td></tr><tr><td align="left">行内块元素</td><td align="center">一行可以放多个</td><td align="center">可以设置宽度高度</td><td align="center">它本身内容的宽度</td><td align="center"></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>about</title>
    <link href="/2024/02/27/hello-world/"/>
    <url>/2024/02/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
